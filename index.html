<!DOCTYPE html>
<html>
<head>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
    <style>
        :root {
            --snapshot-color: rgb(225 29 72);
            --snapshot-color-dark: hsl(from var(--snapshot-color) h s calc(l - 5));
        }

        button#snapshot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            background: var(--snapshot-color);
            border-radius: 50%;
            border: none;
            outline-offset: 2px;
            outline: 2px solid var(--snapshot-color);
            padding: 20px;
        }

        button#snapshot:active {
            background: var(--snapshot-color-dark);
            outline: 2px solid var(--snapshot-color-dark);
            padding: 23px;
        }

        /*
        Spinner element is taken from Luke Haas's css-loaders project
        Copyright (c) 2014 Luke Haas, MIT licensed
        https://github.com/lukehaas/css-loaders
        */
        button#snapshot:disabled .spinner {
            display: block !important;
            position: absolute;
            color: #ffffff;
            font-size: 3px;
            width: 1em;
            height: 1em;
            border-radius: 50%;
            /*position: relative;*/
            text-indent: -9999em;
            animation: load4 1.3s infinite linear;
            transform: translateZ(0);
        }

        @keyframes load4 {
            0%,
            100% {
                box-shadow: 0 -3em 0 0.2em, 2em -2em 0 0em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 0;
            }
            12.5% {
                box-shadow: 0 -3em 0 0, 2em -2em 0 0.2em, 3em 0 0 0, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
            }
            25% {
                box-shadow: 0 -3em 0 -0.5em, 2em -2em 0 0, 3em 0 0 0.2em, 2em 2em 0 0, 0 3em 0 -1em, -2em 2em 0 -1em, -3em 0 0 -1em, -2em -2em 0 -1em;
            }
            37.5% {
                box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 0, 2em 2em 0 0.2em, 0 3em 0 0em, -2em 2em 0 -1em, -3em 0em 0 -1em, -2em -2em 0 -1em;
            }
            50% {
                box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 0em, 0 3em 0 0.2em, -2em 2em 0 0, -3em 0em 0 -1em, -2em -2em 0 -1em;
            }
            62.5% {
                box-shadow: 0 -3em 0 -1em, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 0, -2em 2em 0 0.2em, -3em 0 0 0, -2em -2em 0 -1em;
            }
            75% {
                box-shadow: 0em -3em 0 -1em, 2em -2em 0 -1em, 3em 0em 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0.2em, -2em -2em 0 0;
            }
            87.5% {
                box-shadow: 0em -3em 0 0, 2em -2em 0 -1em, 3em 0 0 -1em, 2em 2em 0 -1em, 0 3em 0 -1em, -2em 2em 0 0, -3em 0em 0 0, -2em -2em 0 0.2em;
            }
        }
    </style>
</head>

<body style="display: flex; flex-direction: column;">

<div style="position: relative; font-size:0px;">
    <video autoplay style="max-width: 50%;"></video>
    <button id="snapshot">
        <div class="spinner" style="display:none;"></div>
    </button>
    <canvas id="output" width="1" height="1" style="max-width: 50%;"></canvas>
</div>
<div id="totalCount" style="font-size: 3em; font-family: sans-serif; text-align: center; color: darkgreen;"></div>

<details id="debugPanel">
    <summary>DEBUG</summary>
</details>

<script>
    const SHOW_CONTOURS = true;
    const Log = {
        _logs: [],
        clear: function () {
            const panel = document.querySelector("#debugPanel dl");
            panel.textContent = "";
            // while (panel.lastChild.nodeName !== "SUMMARY") {
            //     panel.removeChild(panel.lastChild);
            // }

            Log._logs = []; // clear array
        },
        _addEntry(name, content) {
            const panel = document.querySelector("#debugPanel dl");
            const dt = document.createElement("dt");
            dt.textContent = name;
            const dd = document.createElement("dd");
            dd.appendChild(content)
            panel.append(dt, dd)
        },
        image: function (text, img) {
            const canvas = document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 1;
            canvas.style = "border: 1px solid black; max-width: 100%;";

            Log._addEntry(text || "Image", canvas)

            cv.imshow(canvas, img); // Must be run once the canvas is already in the DOM

            Log._logs.push({ts: new Date().toISOString(), type: "image", label: text, image: canvas.toDataURL()});
        },
        log: function (text) {
            Log._addEntry("Text", document.createTextNode(text))
            Log._logs.push({ts: new Date().toISOString(), type: "text", text});
        },
        data: function (tag, d) {
            const json = document.createElement("code")
            json.textContent = JSON.stringify(d)
             Log._addEntry("Data", json)
            Log._logs.push({ts: new Date().toISOString(), type: "data", tag, data: d});
        },
        error: function (tag, e) {
            Log._addEntry("Error", document.createTextNode(errString))
            panel.appendChild(document.createTextNode(errString));
            Log._logs.push({ts: new Date().toISOString(), type: "error", tag, data: errString});
        },
    }
    const Button = {
        setup: function () {
            document.getElementById("snapshot").onclick = () => mustProcess = true;
        },
        disable: function () {
            document.getElementById("snapshot").disabled = true
        },
        enable: function () {
            document.getElementById("snapshot").disabled = false
        },
    }

    function median(arr) {
        const middle = Math.floor(arr.length / 2);
        const nums = [...arr].sort((a, b) => a - b);
        return arr.length % 2 !== 0 ? nums[middle] : (nums[middle - 1] + nums[middle]) / 2;
    }

    function processImage(src) {
        Log.image("Source", src)
        let dsize = new cv.Size(1280, 960);
        cv.resize(src, src, dsize, 0, 0, cv.INTER_AREA);

        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_BGR2GRAY, 0);
        Log.image("Grayscale", gray);

        let histSrc = new cv.MatVector();
        histSrc.push_back(gray);
        let hist = new cv.Mat(), mask = new cv.Mat();
        cv.calcHist(histSrc, [0], mask, hist, [256], [0, 255], /*accumulate*/false);
        let max = cv.minMaxLoc(hist, mask).maxVal;
        const histScale = 3, histHeight = 300;
        let histFigure = new cv.Mat.zeros(histHeight, 256 * histScale, cv.CV_8UC3);
        // draw histogram
        for (let i = 0; i < 256; i++) {
            let binVal = hist.data32F[i] * histHeight / max;
            let point1 = new cv.Point(i * histScale, histHeight);
            let point2 = new cv.Point((i + 1) * histScale - 1, histHeight - binVal);
            cv.rectangle(histFigure, point1, point2, [255, 255, 255, 255], cv.FILLED);
        }

        let binary = new cv.Mat();
        Log.log("Thresholding algorithm=Adaptive+invert")
        const blockSize = 51, C = 20;
        Log.data("thresholding params", {blockSize, C})
        // const cutoff = cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
        // const cutoff = cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_TRIANGLE);
        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, blockSize, C);
        const cutoff = -1;
        // draw red line on threshold
        if (cutoff > -1) {
            cv.rectangle(histFigure, {x: cutoff * histScale, y: histHeight}, {
                x: cutoff * histScale + 1,
                y: 0
            }, [255, 0, 0, 255], cv.FILLED);
        }
        Log.image("Hist", histFigure);
        Log.log(`Threshold=${cutoff}`)
        gray.delete();
        hist.delete();
        histSrc.delete();
        mask.delete();
        histFigure.delete();

        let opened = binary.clone();
        Log.image("Opening", opened);

        let blobLabels = new cv.Mat(), blobStats = new cv.Mat(), centroids = new cv.Mat();
        let seedData = [];
        const numBlobs = cv.connectedComponentsWithStats(opened, blobLabels, blobStats, centroids);
        blobLabels.delete();
        opened.delete();
        for (let i = 1; i < numBlobs; i++) {
            const blobStat = blobStats.intPtr(i);
            const x0 = blobStat[0], y0 = blobStat[1];
            const w = blobStat[2], h = blobStat[3];
            const area = blobStat[4];
            const fillRatio = area / (w * h);

            if (area <= 16) continue; // speck of something
            if (fillRatio < 0.3) continue; // same
            if (w / h < 0.05 || w / h > 20) continue; // too skinny, very unlikely to be a row of 20 seeds in a perfect orthogonal row

            const PADDING = 0;
            cv.rectangle(src, new cv.Point(x0 - PADDING, y0 - PADDING), new cv.Point(x0 + w + PADDING, y0 + h + PADDING), [255, 0, 0, 255], 1);
            //cv.putText(src, ""+area/*+"="+fillRatio*/, {x:x0, y:y0-10}, cv.FONT_HERSHEY_SIMPLEX, 0.5, [255,0,0,0], 1)

            seedData.push({
                i,
                corner: {x0, y0},
                center: {x: centroids.doubleAt(i, 0), y: centroids.doubleAt(i, 1)},
                size: {w, h},
                area: blobStat[4],
                fillRatio
            });
        }
        blobStats.delete();
        centroids.delete();
        Log.data("seed_data", seedData);

        const areas = seedData.map(x => x.area);
        const frs = seedData.map(x => x.fillRatio);
        const medianArea = median(areas);

        let totalSeeds = 0;
        for (let seed of seedData) {
            const numSeeds = Math.round(seed.area / medianArea);
            const numSeedsX = (seed.area / medianArea).toFixed(2);
            totalSeeds += numSeeds;
            cv.putText(src, "x" + numSeeds/*+"="+fillRatio*/, {
                x: seed.corner.x0,
                y: seed.corner.y0 - 2
            }, cv.FONT_HERSHEY_SIMPLEX, 0.5, [255, 255, 255, 255], 1)
        }

        Log.data("final_stats", {medianArea, totalSeeds})
        cv.putText(src, "Total=" + totalSeeds, {x: 5, y: 35}, cv.FONT_HERSHEY_SIMPLEX, 1.0, [255, 255, 255, 255], 2)
        Log.image("Output", src);
        cv.imshow("output", src);

        if (SHOW_CONTOURS) {
            let contours = new cv.MatVector(), hierarchy = new cv.Mat();
            cv.findContours(binary, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
            cv.drawContours(src, contours, -1, [0, 0, 255, 255], 1, cv.LINE_8, hierarchy, 100);
            Log.image("Contours", src);
            contours.delete();
            hierarchy.delete();
        }

        return totalSeeds;
    }

    let mustProcess = false;

    async function setupStream() {
        let stream = null;
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                //video: {facingMode: {exact: 'environment'}},
                video: {
                    width: {min: 640, ideal: 1280, max: 1920},
                    height: {min: 480, ideal: 960, max: 1080},
                    advanced: [
                        {facingMode: 'environment'},
                    ],
                },
                audio: false,
            });
        } catch (err) {
            alert("Video stream isn't available! Check that you're using a device with a back-facing camera and that you've granted permission to use it: " + err);
            Log.error("get_user_media", err);
            throw err;
        }

        const video = document.querySelector('video');
        video.srcObject = stream;

        const [track] = stream.getVideoTracks();
        let imageCapture = new ImageCapture(track);
        //track.applyConstraints({frameRate: 5})
        const capabilities = track.getCapabilities();
        Log.data("stream_capabilities", capabilities);
        const settings = track.getSettings();
        Log.data("stream_settings", settings);

        while (true) {
            if (!mustProcess) {
                // Sleep for a bit
                await new Promise(r => setTimeout(r, 200));
                continue;
            }

            mustProcess = false;
            Button.disable()
            Log.clear();
            Log.data("stream_capabilities", capabilities);
            Log.data("stream_settings", settings);
            const processingPromise = new Promise(async (resolve) => {
                const blob = await imageCapture.takePhoto();
                const img = new Image();
                img.addEventListener("load", () => {
                    let src = cv.imread(img);
                    const seeds = processImage(src);
                    src.delete();
                    resolve(seeds);
                });
                img.src = URL.createObjectURL(blob);
            });

            try {
                const seeds = await processingPromise;
                document.getElementById("totalCount").textContent = `${seeds} seeds`
            } catch (error) {
                Log.error("processing_promise", error);
                alert("ERR")
            }
            Button.enable()
        }
    }

    var Module = {
        // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
        onRuntimeInitialized() {
            setupStream();
            Button.setup();
        }
    };
</script>

<!-- Cloudflare Web Analytics -->
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "84cd2fbe6c56408ca10c975fbd303d2e"}'></script>
<!-- End Cloudflare Web Analytics -->
</body>
</html>
